<template>
  <Teleport :to="teleport" v-if="teleport">
    <Transition @before-enter="handleBeforeEnter" @enter="handleEnter" @after-enter="handleAfterEnter">
      <div class="contextmenu" ref="contextmenuElement" v-show="visible" :style="contextMenuPositionStyle">
        <ul class="contextmenu-inner">
          <slot></slot>
        </ul>
      </div>
    </Transition>
  </Teleport>
  <Transition @before-enter="handleBeforeEnter" @enter="handleEnter" @after-enter="handleAfterEnter" v-else>
    <div class="contextmenu" ref="contextmenuElement" v-show="visible" :style="contextMenuPositionStyle">
      <ul class="contextmenu-inner">
        <slot></slot>
      </ul>
    </div>
  </Transition>
</template>
<script setup lang="ts">
const props = defineProps({
  modelValue: {
    type: Boolean,
    default: false
  },
  autoAjustPlacement: {
    type: Boolean,
    default: true
  },
  disabled: {
    type: Boolean,
    default: false
  },
  teleport: {
    type: String,
    default: () => 'body'
  }
})

const emits = defineEmits(['show', 'hide', 'update:modelValue'])
// 右键菜单的元素
const contextmenuElement = ref<HTMLDivElement | null>(null)
// 右键菜单是否显示
const visible = ref(props.modelValue || false)
/**
 * @desc 更新右键菜单的显示状态
 * @param {boolean} value
 */
const updateModelValue = (value: boolean) => {
  visible.value = value
  emits('update:modelValue', value)
}
// 右键菜单的位置
const contextMenuPosition = ref({ top: 0, left: 0 })
/**
 * @desc 右键菜单的位置
 * @type {ComputedRef<{ top: string; left: string }>}
 */
const contextMenuPositionStyle = computed(() => ({
  top: `${contextMenuPosition.value.top}px`,
  left: `${contextMenuPosition.value.left}px`
}))

/**
 * @desc 显示菜单
 * @param { MouseEvent } evt
 * @returns {void}
 */
const showContextMenu = (evt: MouseEvent) => {
  evt.preventDefault()
  evt.stopPropagation()
  // 先关闭再打开，防止多次右键菜单叠加
  updateModelValue(false)
  nextTick(() => {
    const autoAjustPlacement = props.autoAjustPlacement
    const targetPosition = {
      top: evt.pageY,
      left: evt.pageX
    }
    if (autoAjustPlacement) {
      const contextmenuNode = contextmenuElement.value
      if (contextmenuNode) {
        const contextmenuWidth = contextmenuNode.clientWidth
        const contextmenuHeight = contextmenuNode.clientHeight
        if (contextmenuHeight + targetPosition.top >= window.innerHeight + window.scrollY) {
          const targetTop = targetPosition.top - contextmenuHeight
          if (targetTop > window.scrollY) {
            targetPosition.top = targetTop
          }
        }
        if (contextmenuWidth + targetPosition.left >= window.innerWidth + window.scrollX) {
          const targetWidth = targetPosition.left - contextmenuWidth
          if (targetWidth > window.scrollX) {
            targetPosition.left = targetWidth
          }
        }
      }
    }
    contextMenuPosition.value = targetPosition
    updateModelValue(true)
    emits('show')
  })
}
/**
 * @desc 隐藏菜单
 */
const hideContextMenu = () => {
  updateModelValue(false)
  // TODO: 添加回掉参数
  emits('hide')
}
/**
 * @desc 当dom元素进入到页面之前
 * @param {Element} el
 */
const handleBeforeEnter = (el: Element) => {
  ;(el as HTMLDivElement).style.height = '0'
}
/**
 * @desc 当dom元素进入到页面之后
 * @param {Element} el
 */
const handleEnter = (el: Element) => {
  ;(el as HTMLDivElement).style.height = 'auto'
  const realHeight = window.getComputedStyle(el).height
  ;(el as HTMLDivElement).style.height = '0'
  requestAnimationFrame(() => {
    ;(el as HTMLDivElement).style.height = realHeight
    ;(el as HTMLDivElement).style.transition = 'height .5s'
  })
}
/**
 * @desc 当dom元素进入到页面之后
 * @param {Element} el
 */
const handleAfterEnter = (el: Element) => {
  ;(el as HTMLDivElement).style.transition = 'none'
}
/**
 * @desc 触发元素的配置
 */
const contextMenuOptions = reactive<Map<Element, ContextMenu.ContextMenuOtions>>(new Map())
/**
 * @desc 当前触发元素
 * @type {Ref<ContextMenu.ContextMenuElement>}
 */
const currentReferenceElement = ref<ContextMenu.ContextMenuElement>()
/**
 * @desc 当前触发元素的配置
 * @type {ComputedRef<ContextMenu.ContextMenuOptions>}
 */
const currentTriggerOptions = computed(
  () => currentReferenceElement.value && contextMenuOptions.get(currentReferenceElement.value)
)
/**
 * @desc 添加触发元素
 * @param {ContextMenu.ContextMenuElement} contextMenuElement
 * @param {ContextMenu.InitContextMenuOptions} options
 * @returns {void}
 */
const initContextMenuEvent = (
  contextMenuElement: ContextMenu.ContextMenuElement,
  options?: ContextMenu.InitContextMenuOptions
): void => {
  // 获取用户的触发方式
  const triggerTypes: ContextMenu.TriggerType[] = options?.triggerTypes
    ? Array.isArray(options.triggerTypes)
      ? options.triggerTypes
      : [options.triggerTypes]
    : ['contextmenu']
  /**
   * @desc 触发事件
   * @param {Event} evt
   * @returns {void}
   */
  const triggerEventHandler = (evt: Event) => {
    if (props.disabled) return
    currentReferenceElement.value = contextMenuElement
    showContextMenu(evt as MouseEvent)
  }
  /**
   * @desc 循环绑定事件
   * @param {ContextMenu.TriggerType} triggerType
   * @returns {void}
   */
  triggerTypes.forEach((triggerType) => {
    contextMenuElement.addEventListener(triggerType, triggerEventHandler)
  })
  /**
   * @desc 保存触发元素
   */
  contextMenuOptions.set(contextMenuElement, {
    triggerTypes,
    triggerEventHandler
  })
}
/**
 * @desc 移除触发元素
 * @param {ContextMenu.ContextMenuElement} contextMenuElement
 * @returns {void}
 */
const removeContextMenuEvent = (contextMenuElement: ContextMenu.ContextMenuElement): void => {
  const options = contextMenuOptions.get(contextMenuElement)
  if (!options) return
  options.triggerTypes.forEach((triggerType) => {
    contextMenuElement.removeEventListener(triggerType, options.triggerEventHandler)
  })
  contextMenuOptions.delete(contextMenuElement)
}
/**
 * @desc 当用户点击body时，隐藏菜单
 * @param {Event} evt
 * @returns {void}
 */
const handleClickBody = (evt: Event): void => {
  if (!evt.target || !contextmenuElement.value) return
  // 只要点击不在菜单内就关闭菜单
  if (!contextmenuElement.value.contains(evt.target as Node)) {
    updateModelValue(false)
  }
}
// esc关闭菜单
const handleEscKey = (evt: KeyboardEvent) => {
  if (evt.key === 'Escape') {
    updateModelValue(false)
  }
}

watch(visible, (value) => {
  if (value) {
    // 显示菜单时，添加事件监听
    document.addEventListener('click', handleClickBody)
    document.addEventListener('keydown', handleEscKey)
  } else {
    // 隐藏菜单时，移除事件监听
    document.removeEventListener('click', handleClickBody)
    document.removeEventListener('keydown', handleEscKey)
  }
})
/**
 * @desc 当用户离开页面时，移除事件监听
 */
onBeforeUnmount(() => {
  document.removeEventListener('click', handleClickBody)
  document.removeEventListener('keydown', handleEscKey)
})

provide('visible', visible)
provide('autoAjustPlacement', props.autoAjustPlacement)
provide('show', showContextMenu)
provide('hide', hideContextMenu)

defineExpose({
  initContextMenuEvent,
  removeContextMenuEvent,
  show: showContextMenu,
  hide: hideContextMenu
})
</script>
