#!/bin/bash

# Implementation Plan Task List and Thought in Chinese
# 1. 将 expect 逻辑转换为纯 shell 脚本
# 2. 使用 sshpass 处理密码（如果本地已安装）或提示用户手动输入
# 3. 保持核心的 iptables 修复逻辑不变
# 4. 适配当前项目的网络名称 dms-network

HOST="100.109.41.26"
USER="root"
# PASSWORD 建议通过环境变量设置，或者运行脚本时手动输入
NETWORK_NAME="dms-network"

# 如果没有设置环境变量 SSH_PASS，则交互式询问
if [ -z "$SSH_PASS" ]; then
    read -sp "Enter password for $USER@$HOST: " SSH_PASS
    echo ""
fi

echo "Connecting to $HOST to fix Docker network issues..."

# 构建要在远程服务器上执行的命令
REMOTE_COMMANDS=$(cat <<EOF
    # --- Docker Network Fix Script ---

    # 1. 尝试通过标签获取网络名称（兼容 Compose 自动生成的名称）
    # 这里的标签是 docker-compose 默认添加的
    NETWORK_NAME=\$(docker network ls --filter label=com.docker.compose.network=$NETWORK_NAME --format "{{.Name}}" | head -n 1)

    # 如果没找到，尝试默认名称
    if [ -z "\$NETWORK_NAME" ]; then
        NETWORK_NAME="$NETWORK_NAME"
    fi

    echo "Target Network: \$NETWORK_NAME"

    # 2. 动态获取网桥名和子网
    # 获取 Network ID 的前12位
    DMS_ID=\$(docker network inspect \$NETWORK_NAME -f '{{.Id}}' 2>/dev/null | cut -c1-12)

    if [ -z "\$DMS_ID" ]; then
        echo "ERROR: Network '\$NETWORK_NAME' not found or ID is empty."
        exit 1
    fi

    DMS_BRIDGE="br-\$DMS_ID"
    DMS_SUBNET=\$(docker network inspect \$NETWORK_NAME -f '{{(index .IPAM.Config 0).Subnet}}' 2>/dev/null)

    # 3. 动态获取 WAN 接口
    # 从默认路由获取出口接口 (更准确，兼容 PPPoE)
    WAN_INTERFACE=\$(ip route show default | awk '/default/ {print \$5}' | head -n 1)

    # 如果获取失败，回退到 eth0
    if [ -z "\$WAN_INTERFACE" ]; then
        WAN_INTERFACE="eth0"
    fi

    echo "Detected Bridge: \$DMS_BRIDGE"
    echo "Detected Subnet: \$DMS_SUBNET"
    echo "Detected WAN:    \$WAN_INTERFACE"

    if [ -z "\$DMS_SUBNET" ]; then
        echo "ERROR: Could not determine subnet for network."
        exit 1
    fi

    # 4. 清理旧规则（防止重复叠加）
    # 使用 iptables -D 尝试删除可能存在的规则，忽略错误
    iptables -D FORWARD -i \$DMS_BRIDGE -p tcp --dport 465 -j ACCEPT 2>/dev/null
    iptables -D FORWARD -i \$WAN_INTERFACE -o \$DMS_BRIDGE -p tcp --sport 465 -j ACCEPT 2>/dev/null
    iptables -D FORWARD -i \$DMS_BRIDGE -p tcp --dport 443 -j ACCEPT 2>/dev/null
    iptables -D FORWARD -i \$WAN_INTERFACE -o \$DMS_BRIDGE -p tcp --sport 443 -j ACCEPT 2>/dev/null
    iptables -D FORWARD -i \$DMS_BRIDGE -p tcp --dport 80 -j ACCEPT 2>/dev/null
    iptables -D FORWARD -i \$WAN_INTERFACE -o \$DMS_BRIDGE -p tcp --sport 80 -j ACCEPT 2>/dev/null

    # 清理之前错误的规则 (output interface for return traffic)
    iptables -D FORWARD -o \$WAN_INTERFACE -p tcp --sport 465 -j ACCEPT 2>/dev/null
    iptables -D FORWARD -o \$WAN_INTERFACE -p tcp --sport 443 -j ACCEPT 2>/dev/null
    iptables -D FORWARD -o \$WAN_INTERFACE -p tcp --sport 80 -j ACCEPT 2>/dev/null

    iptables -t nat -D POSTROUTING -s \$DMS_SUBNET -o \$WAN_INTERFACE -j MASQUERADE 2>/dev/null

    # 同时也清理 /etc/firewall.user 中的旧标记块
    sed -i '/# --- Docker Network Fix Start ---/,/# --- Docker Network Fix End ---/d' /etc/firewall.user

    # 5. 写入新的修复规则到 /etc/firewall.user (持久化)
    cat >> /etc/firewall.user <<INNER_EOF

# --- Docker Network Fix Start ---
# Generated by fix-network.sh at \$(date)
# Bridge: \$DMS_BRIDGE, Subnet: \$DMS_SUBNET, WAN: \$WAN_INTERFACE

# Allow SMTP (465)
iptables -I FORWARD 1 -i \$DMS_BRIDGE -p tcp --dport 465 -j ACCEPT
iptables -I FORWARD 1 -i \$WAN_INTERFACE -o \$DMS_BRIDGE -p tcp --sport 465 -j ACCEPT

# Allow HTTPS (443)
iptables -I FORWARD 1 -i \$DMS_BRIDGE -p tcp --dport 443 -j ACCEPT
iptables -I FORWARD 1 -i \$WAN_INTERFACE -o \$DMS_BRIDGE -p tcp --sport 443 -j ACCEPT

# Allow HTTP (80)
iptables -I FORWARD 1 -i \$DMS_BRIDGE -p tcp --dport 80 -j ACCEPT
iptables -I FORWARD 1 -i \$WAN_INTERFACE -o \$DMS_BRIDGE -p tcp --sport 80 -j ACCEPT

# NAT Masquerade
iptables -t nat -I POSTROUTING 1 -s \$DMS_SUBNET -o \$WAN_INTERFACE -j MASQUERADE
# --- Docker Network Fix End ---
INNER_EOF

    # 6. 立即应用规则 (无需重启防火墙，避免断网)
    echo "Applying rules immediately..."
    iptables -I FORWARD 1 -i \$DMS_BRIDGE -p tcp --dport 465 -j ACCEPT
    iptables -I FORWARD 1 -i \$WAN_INTERFACE -o \$DMS_BRIDGE -p tcp --sport 465 -j ACCEPT

    iptables -I FORWARD 1 -i \$DMS_BRIDGE -p tcp --dport 443 -j ACCEPT
    iptables -I FORWARD 1 -i \$WAN_INTERFACE -o \$DMS_BRIDGE -p tcp --sport 443 -j ACCEPT

    iptables -I FORWARD 1 -i \$DMS_BRIDGE -p tcp --dport 80 -j ACCEPT
    iptables -I FORWARD 1 -i \$WAN_INTERFACE -o \$DMS_BRIDGE -p tcp --sport 80 -j ACCEPT

    iptables -t nat -I POSTROUTING 1 -s \$DMS_SUBNET -o \$WAN_INTERFACE -j MASQUERADE

    echo "FIX_COMPLETED_SUCCESSFULLY"
EOF
)

# 使用 ssh 执行远程命令
# 注意：这里假设你本地环境支持 sshpass，或者已经配置了 SSH 免密登录
# 如果没有 sshpass，建议配置 SSH Key 免密登录，安全性更高
if command -v sshpass &> /dev/null; then
    sshpass -p "$SSH_PASS" ssh -o StrictHostKeyChecking=no $USER@$HOST "$REMOTE_COMMANDS"
else
    echo "Warning: 'sshpass' not found. Trying standard ssh..."
    ssh -o StrictHostKeyChecking=no $USER@$HOST "$REMOTE_COMMANDS"
fi
